var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var C=Object.prototype.hasOwnProperty;var w=o=>c(o,"__esModule",{value:!0});var S=(o,e)=>{for(var i in e)c(o,i,{get:e[i],enumerable:!0})},k=(o,e,i,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let t of A(e))!C.call(o,t)&&(i||t!=="default")&&c(o,t,{get:()=>e[t],enumerable:!(n=g(e,t))||n.enumerable});return o};var _=(o=>(e,i)=>o&&o.get(e)||(i=k(w({}),e,1),o&&o.set(e,i),i))(typeof WeakMap!="undefined"?new WeakMap:0);var I={};S(I,{default:()=>U});var y=require("./utils/defineCustomElement.js"),a=require("./utils/server-safe-globals.js"),r=require("./constants.js"),m=require("./labels/labels.js");const f=a.Document.createElement("template");f.innerHTML=`
  <style>
    :host {
      box-sizing: border-box;
      position: relative;
      display: inline-block;
      line-height: 0;
      background-color: #000;
    }

    :host(:not([audio])) *[part~=layer]:not([part~=media-layer]) {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      display: flex;
      flex-flow: column nowrap;
      align-items: start;
      pointer-events: none;
      background: none;
    }

    :host(:not([audio])) :is([part~=gestures-layer],[part~=media-layer])  {
      pointer-events: auto;
    }
    
    :host(:not([audio])) *[part~=layer][part~=centered-layer] {
      align-items: center;
      justify-content: center;
    }

    .spacer {
      pointer-events: none;
      background: none;
    }

    /* Position the media and poster elements to fill the container */
    ::slotted([slot=media]),
    ::slotted([slot=poster]) {
      width: 100%;
      height: 100%;
    }

    /* Video specific styles */
    :host(:not([audio])) .spacer {
      flex-grow: 1;
    }

    /* Safari needs this to actually make the element fill the window */
    :host(:-webkit-full-screen) {
      /* Needs to use !important otherwise easy to break */
      width: 100% !important;
      height: 100% !important;
    }

    /* Need to revisit this. May be too presumptuous for user-inactive behavior */
    ::slotted(:not([slot=media]):not([slot=poster])) {
      pointer-events: auto;
    }

    /* Only add these if auto hide is not disabled */
    ::slotted(:not([slot=media]):not([no-auto-hide])) {
      opacity: 1;
      transition: opacity 0.25s;
    }

    /* Hide controls when inactive, not paused, not audio and auto hide not disabled */
    :host([user-inactive]:not([${r.MediaUIAttributes.MEDIA_PAUSED}]):not([audio])) ::slotted(:not([slot=media]):not([no-auto-hide])) {
      opacity: 0;
      transition: opacity 1s;
    }

    ::slotted(media-control-bar)  {
      align-self: stretch;
    }
  </style>

  <span part="layer media-layer">
    <slot name="media"></slot>
  </span>
  <span part="layer poster-layer">
    <slot name="poster"></slot>
  </span>
  <span part="layer gesture-layer">
    <slot name="gestures-chrome"></slot>
  </span>
  <span part="layer vertical-layer">
    <slot name="top-chrome"></slot>
    <span class="spacer"><slot name="middle-chrome"></slot></span>
    <!-- default, effectively "bottom-chrome" -->
    <slot></slot>
  </span>
  <span part="layer centered-layer">
    <slot name="centered-chrome"></slot>
  </span>
`;const M=Object.values(r.MediaUIAttributes);class E extends a.Window.HTMLElement{constructor(){super();const e=this.attachShadow({mode:"open"});this.shadowRoot.appendChild(f.content.cloneNode(!0));const i=(p,b)=>{const h=this.media;for(let d of p)d.type==="childList"&&(d.removedNodes.forEach(u=>{if(u.slot=="media"&&d.target==this){let l=d.previousSibling&&d.previousSibling.previousElementSibling;if(!l||!h)this.mediaUnsetCallback(u);else{let v=l.slot!=="media";for(;(l=l.previousSibling)!==null;)l.slot=="media"&&(v=!1);v&&this.mediaUnsetCallback(u)}}}),h&&d.addedNodes.forEach(u=>{u==h&&this.handleMediaUpdated(h).then(l=>this.mediaSetCallback(l))}))};new MutationObserver(i).observe(this,{childList:!0,subtree:!0});let t=this.media,s=this.querySelector(":scope > slot[slot=media]");s&&s.addEventListener("slotchange",()=>{if(!s.assignedElements({flatten:!0}).length){this.mediaUnsetCallback(t);return}this.media&&(t=this.media,this.handleMediaUpdated(this.media).then(b=>this.mediaSetCallback(b)))})}static get observedAttributes(){return["autohide"].concat(M)}attributeChangedCallback(e,i,n){e.toLowerCase()=="autohide"&&(this.autohide=n)}get media(){let e=this.querySelector(":scope > [slot=media]");return(e==null?void 0:e.nodeName)=="SLOT"&&(e=e.assignedElements({flatten:!0})[0]),e}mediaSetCallback(e){this._mediaClickPlayToggle=i=>{const n=e.paused?r.MediaUIEvents.MEDIA_PLAY_REQUEST:r.MediaUIEvents.MEDIA_PAUSE_REQUEST;this.dispatchEvent(new a.Window.CustomEvent(n,{composed:!0,bubbles:!0}))}}handleMediaUpdated(e){const i=s=>Promise.resolve(s),n=s=>(console.error('<media-chrome>: Media element set with slot="media" does not appear to be compatible.',s),Promise.reject(s));if(!e)return n(e);const t=e.nodeName.toLowerCase();return t.includes("-")?a.Window.customElements.whenDefined(t).then(()=>i(e)):i(e)}mediaUnsetCallback(e){}connectedCallback(){const i=this.getAttribute("audio")!=null?m.nouns.AUDIO_PLAYER():m.nouns.VIDEO_PLAYER();this.setAttribute("role","region"),this.setAttribute("aria-label",i),this.media&&this.handleMediaUpdated(this.media).then(t=>this.mediaSetCallback(t)),this.setAttribute("user-inactive","user-inactive");const n=()=>{this.removeAttribute("user-inactive");const t=new a.Window.CustomEvent(r.MediaStateChangeEvents.USER_INACTIVE,{composed:!0,bubbles:!0,detail:!1});this.dispatchEvent(t),a.Window.clearTimeout(this._inactiveTimeout),!(this.autohide<0)&&(this._inactiveTimeout=a.Window.setTimeout(()=>{this.setAttribute("user-inactive","user-inactive");const s=new a.Window.CustomEvent(r.MediaStateChangeEvents.USER_INACTIVE,{composed:!0,bubbles:!0,detail:!0});this.dispatchEvent(s)},this.autohide*1e3))};this.addEventListener("keyup",t=>{n()}),this.addEventListener("keyup",t=>{this.setAttribute("media-keyboard-control","media-keyboard-control")}),this.addEventListener("mouseup",t=>{this.removeAttribute("media-keyboard-control")}),this.addEventListener("mousemove",t=>{if(t.target===this)return;this.removeAttribute("user-inactive");const s=new a.Window.CustomEvent(r.MediaStateChangeEvents.USER_INACTIVE,{composed:!0,bubbles:!0,detail:!1});this.dispatchEvent(s),a.Window.clearTimeout(this._inactiveTimeout),t.target===this.media&&n()}),this.addEventListener("mouseleave",t=>{if(this.autohide<0)return;this.setAttribute("user-inactive","user-inactive");const s=new a.Window.CustomEvent(r.MediaStateChangeEvents.USER_INACTIVE,{composed:!0,bubbles:!0,detail:!0});this.dispatchEvent(s)})}set autohide(e){e=Number(e),this._autohide=isNaN(e)?0:e}get autohide(){return this._autohide===void 0?2:this._autohide}}(0,y.defineCustomElement)("media-container-temp",E);var U=E;module.exports=_(I);
//# sourceMappingURL=media-container.js.map
