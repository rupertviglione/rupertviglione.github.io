{
  "version": 3,
  "sources": ["../../src/js/media-container.js"],
  "sourcesContent": ["/*\n  The <media-chrome> can contain the control elements\n  and the media element. Features:\n  * Auto-set the `media` attribute on child media chrome elements\n    * Uses the element with slot=\"media\"\n  * Take custom controls to fullscreen\n  * Position controls at the bottom\n  * Auto-hide controls on inactivity while playing\n*/\nimport { defineCustomElement } from './utils/defineCustomElement.js';\nimport {\n  Window as window,\n  Document as document,\n} from './utils/server-safe-globals.js';\nimport { MediaUIEvents, MediaUIAttributes, MediaStateChangeEvents } from './constants.js';\nimport { nouns } from './labels/labels.js';\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n  <style>\n    :host {\n      box-sizing: border-box;\n      position: relative;\n      display: inline-block;\n      line-height: 0;\n      background-color: #000;\n    }\n\n    :host(:not([audio])) *[part~=layer]:not([part~=media-layer]) {\n      position: absolute;\n      top: 0;\n      left: 0;\n      bottom: 0;\n      right: 0;\n      display: flex;\n      flex-flow: column nowrap;\n      align-items: start;\n      pointer-events: none;\n      background: none;\n    }\n\n    :host(:not([audio])) :is([part~=gestures-layer],[part~=media-layer])  {\n      pointer-events: auto;\n    }\n    \n    :host(:not([audio])) *[part~=layer][part~=centered-layer] {\n      align-items: center;\n      justify-content: center;\n    }\n\n    .spacer {\n      pointer-events: none;\n      background: none;\n    }\n\n    /* Position the media and poster elements to fill the container */\n    ::slotted([slot=media]),\n    ::slotted([slot=poster]) {\n      width: 100%;\n      height: 100%;\n    }\n\n    /* Video specific styles */\n    :host(:not([audio])) .spacer {\n      flex-grow: 1;\n    }\n\n    /* Safari needs this to actually make the element fill the window */\n    :host(:-webkit-full-screen) {\n      /* Needs to use !important otherwise easy to break */\n      width: 100% !important;\n      height: 100% !important;\n    }\n\n    /* Need to revisit this. May be too presumptuous for user-inactive behavior */\n    ::slotted(:not([slot=media]):not([slot=poster])) {\n      pointer-events: auto;\n    }\n\n    /* Only add these if auto hide is not disabled */\n    ::slotted(:not([slot=media]):not([no-auto-hide])) {\n      opacity: 1;\n      transition: opacity 0.25s;\n    }\n\n    /* Hide controls when inactive, not paused, not audio and auto hide not disabled */\n    :host([user-inactive]:not([${MediaUIAttributes.MEDIA_PAUSED}]):not([audio])) ::slotted(:not([slot=media]):not([no-auto-hide])) {\n      opacity: 0;\n      transition: opacity 1s;\n    }\n\n    ::slotted(media-control-bar)  {\n      align-self: stretch;\n    }\n  </style>\n\n  <span part=\"layer media-layer\">\n    <slot name=\"media\"></slot>\n  </span>\n  <span part=\"layer poster-layer\">\n    <slot name=\"poster\"></slot>\n  </span>\n  <span part=\"layer gesture-layer\">\n    <slot name=\"gestures-chrome\"></slot>\n  </span>\n  <span part=\"layer vertical-layer\">\n    <slot name=\"top-chrome\"></slot>\n    <span class=\"spacer\"><slot name=\"middle-chrome\"></slot></span>\n    <!-- default, effectively \"bottom-chrome\" -->\n    <slot></slot>\n  </span>\n  <span part=\"layer centered-layer\">\n    <slot name=\"centered-chrome\"></slot>\n  </span>\n`;\n\nconst MEDIA_UI_ATTRIBUTE_NAMES = Object.values(MediaUIAttributes);\n\nclass MediaContainer extends window.HTMLElement {\n  constructor() {\n    super();\n\n    // Set up the Shadow DOM\n    const shadow = this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n\n    // Watch for child adds/removes and update the media element if necessary\n    const mutationCallback = (mutationsList, observer) => {\n      const media = this.media;\n\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n          // Media element being removed\n          mutation.removedNodes.forEach((node) => {\n            // Is this a direct child media element of media-controller?\n            // TODO: This accuracy doesn't matter after moving away from media attrs.\n            // Could refactor so we can always just call 'dispose' on any removed media el.\n            if (node.slot == 'media' && mutation.target == this) {\n              // Check if this was the current media by if it was the first\n              // el with slot=media in the child list. There could be multiple.\n              let previousSibling =\n                mutation.previousSibling &&\n                mutation.previousSibling.previousElementSibling;\n\n              // Must have been first if no prev sibling or new media\n              if (!previousSibling || !media) {\n                this.mediaUnsetCallback(node);\n              } else {\n                // Check if any prev siblings had a slot=media\n                // Should remain true otherwise\n                let wasFirst = previousSibling.slot !== 'media';\n                while (\n                  (previousSibling = previousSibling.previousSibling) !== null\n                ) {\n                  if (previousSibling.slot == 'media') wasFirst = false;\n                }\n                if (wasFirst) this.mediaUnsetCallback(node);\n              }\n            }\n          });\n\n          // Controls or media element being added\n          // No need to inject anything if media=null\n          if (media) {\n            mutation.addedNodes.forEach((node) => {\n              if (node == media) {\n                // Update all controls with new media if this is the new media\n                this.handleMediaUpdated(media).then((media) =>\n                  this.mediaSetCallback(media)\n                );\n              }\n            });\n          }\n        }\n      }\n    };\n\n    const observer = new MutationObserver(mutationCallback);\n    observer.observe(this, { childList: true, subtree: true });\n\n    // Handles the case when the slotted media element is a slot element itself.\n    // e.g. chaining media slots for media themes.\n    let currentMedia = this.media;\n    let chainedSlot = this.querySelector(':scope > slot[slot=media]');\n    if (chainedSlot) {\n      chainedSlot.addEventListener('slotchange', () => {\n        const slotEls = chainedSlot.assignedElements({ flatten: true });\n        if (!slotEls.length) {\n          this.mediaUnsetCallback(currentMedia);\n          return;\n        }\n        if (this.media) {\n          currentMedia = this.media\n          this.handleMediaUpdated(this.media).then((media) =>\n            this.mediaSetCallback(media)\n          );\n        }\n      });\n    }\n  }\n\n  static get observedAttributes() {\n    return ['autohide'].concat(MEDIA_UI_ATTRIBUTE_NAMES);\n  }\n\n  // Could share this code with media-chrome-html-element instead\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName.toLowerCase() == 'autohide') {\n      this.autohide = newValue;\n    }\n  }\n\n  // First direct child with slot=media, or null\n  get media() {\n    let media = this.querySelector(':scope > [slot=media]');\n\n    // Chaining media slots for media templates\n    if (media?.nodeName == 'SLOT')\n      media = media.assignedElements({ flatten: true })[0];\n\n    return media;\n  }\n\n  mediaSetCallback(media) {\n    // Toggle play/pause with clicks on the media element itself\n    this._mediaClickPlayToggle = (_e) => {\n      const eventName = media.paused\n        ? MediaUIEvents.MEDIA_PLAY_REQUEST\n        : MediaUIEvents.MEDIA_PAUSE_REQUEST;\n      this.dispatchEvent(\n        new window.CustomEvent(eventName, { composed: true, bubbles: true })\n      );\n    };\n  }\n\n  handleMediaUpdated(media) {\n    const resolveMediaPromise = (media) => {\n      // media.addEventListener('click', this._mediaClickPlayToggle, false);\n\n      return Promise.resolve(media);\n    };\n\n    const rejectMediaPromise = (media) => {\n      console.error(\n        '<media-chrome>: Media element set with slot=\"media\" does not appear to be compatible.',\n        media\n      );\n      return Promise.reject(media);\n    };\n\n    // Anything \"falsy\" couldn't act as a media element. Reject.\n    if (!media) {\n      return rejectMediaPromise(media);\n    }\n\n    const mediaName = media.nodeName.toLowerCase();\n    // Custom element. Wait until it's defined before resolving\n    if (mediaName.includes('-')) {\n      return window.customElements.whenDefined(mediaName).then(() => {\n        return resolveMediaPromise(media);\n      });\n    }\n\n    // Exists and isn't a custom element. Resolve.\n    return resolveMediaPromise(media);\n  }\n\n  mediaUnsetCallback(media) {\n    // media.removeEventListener('click', this._mediaClickPlayToggle);\n  }\n\n  connectedCallback() {\n    const isAudioChrome = this.getAttribute('audio') != null;\n    const label = isAudioChrome ? nouns.AUDIO_PLAYER() : nouns.VIDEO_PLAYER();\n    this.setAttribute('role', 'region');\n    this.setAttribute('aria-label', label);\n\n    if (this.media) {\n      this.handleMediaUpdated(this.media).then((media) =>\n        this.mediaSetCallback(media)\n      );\n    }\n\n    // Assume user is inactive until they're not (aka user-inactive by default is true)\n    // This allows things like autoplay and programmatic playing to also initiate hiding controls (CJP)\n    this.setAttribute('user-inactive', 'user-inactive');\n\n    const scheduleInactive = () => {\n      this.removeAttribute('user-inactive');\n      const evt = new window.CustomEvent(\n        MediaStateChangeEvents.USER_INACTIVE, \n        { composed: true, bubbles: true, detail: false }\n      );\n      this.dispatchEvent(evt);\n      window.clearTimeout(this._inactiveTimeout);\n\n      // Setting autohide to -1 turns off autohide\n      if (this.autohide < 0) return;\n\n      this._inactiveTimeout = window.setTimeout(() => {\n        this.setAttribute('user-inactive', 'user-inactive');\n        const evt = new window.CustomEvent(\n          MediaStateChangeEvents.USER_INACTIVE, \n          { composed: true, bubbles: true, detail: true }\n        );\n        this.dispatchEvent(evt);\n      }, this.autohide * 1000);\n    };\n\n    // Unhide for keyboard controlling\n    this.addEventListener('keyup', (e) => {\n      scheduleInactive();\n    });\n\n    // Allow for focus styles only when using the keyboard to navigate\n    this.addEventListener('keyup', (e) => {\n      this.setAttribute('media-keyboard-control', 'media-keyboard-control');\n    });\n    this.addEventListener('mouseup', (e) => {\n      this.removeAttribute('media-keyboard-control');\n    });\n\n    this.addEventListener('mousemove', (e) => {\n      if (e.target === this) return;\n\n      // Stay visible if hovered over control bar\n      this.removeAttribute('user-inactive');\n      const evt = new window.CustomEvent(\n        MediaStateChangeEvents.USER_INACTIVE, \n        { composed: true, bubbles: true, detail: false }\n      );\n      this.dispatchEvent(evt);\n      window.clearTimeout(this._inactiveTimeout);\n\n      // If hovering over the media element we're free to make inactive\n      if (e.target === this.media) {\n        scheduleInactive();\n      }\n    });\n\n    // Immediately hide if mouse leaves the container\n    this.addEventListener('mouseleave', (e) => {\n      if (this.autohide < 0) return;\n      this.setAttribute('user-inactive', 'user-inactive');\n      const evt = new window.CustomEvent(\n        MediaStateChangeEvents.USER_INACTIVE, \n        { composed: true, bubbles: true, detail: true }\n      );\n      this.dispatchEvent(evt);\n    });\n  }\n\n  set autohide(seconds) {\n    seconds = Number(seconds);\n    this._autohide = isNaN(seconds) ? 0 : seconds;\n  }\n\n  get autohide() {\n    return this._autohide === undefined ? 2 : this._autohide;\n  }\n}\n\n// Aliasing media-controller to media-container in main index until we know\n// we're not breaking people with the change.\ndefineCustomElement('media-container-temp', MediaContainer);\n\nexport default MediaContainer;\n"],
  "mappings": "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",
  "names": []
}
