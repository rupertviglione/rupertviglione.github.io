{
  "version": 3,
  "sources": ["../../../src/js/utils/captions.js"],
  "sourcesContent": ["// NOTE: This is generic for any CSS/html list representation. Consider renaming and moving to generic module.\n/**\n * Splits a string (representing TextTracks) into an array of strings based on whitespace.\n * @param {string} [textTracksStr = ''] - a string of 1+ \"items\" (representing TextTracks), separated by whitespace\n * @returns {Array<string>} An array of non-whitesace strings (each representing a single TextTrack).\n */\nexport const splitTextTracksStr = (textTracksStr = '') =>\n  textTracksStr.split(/\\s+/);\n\n/**\n * Parses a string that represents a TextTrack into a \"TextTrack-like object\"\n * The expected TextTrack string format is:\n * \"language[:label]\"\n * where the language *should* conform to BCP 47, just like TextTracks, and the (optional)\n * label *must* be URL encoded.\n * Note that this format may be expanded to include additional properties, such as\n * `id`.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n * @param {string} [textTrackStr = ''] - A well-defined TextTrack string representations\n * @returns {Object} An object that resembles a (partial) TextTrack (`{ language: string; label?: string; }`)\n */\nexport const parseTextTrackStr = (textTrackStr = '') => {\n  const [language, encodedLabel] = textTrackStr.split(':');\n  const label = encodedLabel ? decodeURIComponent(encodedLabel) : undefined;\n  return {\n    language,\n    label,\n  };\n};\n\n/**\n * Parses a whitespacae-separated string that represents list of TextTracks into an array of TextTrack-like objects,\n * where each object will have the properties identified by the corresponding string, plus any properties generically\n * provided by the (optional) `textTrackLikeObj` argument.\n * @param {string} [textTracksStr = ''] - a string of 1+ \"items\" (representing TextTracks), separated by whitespace\n * @param {Object} [textTrackLikeObj] An object that resembles a (partial) TextTrack, used to add generic properties to all parsed TextTracks.\n * @returns {Array<Object>} An array of \"TextTrack-like objects\", each with properties parsed from the string and any properties from `textTrackLikeObj`.\n * @example\n * ```js\n * const tracksStr = 'en-US:English en:English%20%28with%20descriptions%29';\n * const tracks = parseTextTracksStr(tracksStr);\n * // [{ language: 'en-US', label: 'English' }, { language: 'en', label: 'English (with descriptions)' }];\n *\n * const tracksData = { kind: 'captions' };\n * const tracksWithData = parseTextTracksStr(tracksStr, tracksData);\n * // [{ language: 'en-US', label: 'English', kind: 'captions' }, { language: 'en', label: 'English (with descriptions)', kind: 'captions' }];\n * ```\n */\nexport const parseTextTracksStr = (\n  textTracksStr = '',\n  textTrackLikeObj = {}\n) => {\n  return splitTextTracksStr(textTracksStr).map((textTrackStr) => {\n    const textTrackObj = parseTextTrackStr(textTrackStr);\n    return {\n      ...textTrackLikeObj,\n      ...textTrackObj,\n    };\n  });\n};\n\n/**\n * Takes a variety of possible representations of TextTrack(s) and \"normalizes\" them to an Array of 1+ TextTrack-like objects.\n * @param {Array<string|Object>|string|Object} trackOrTracks - A value representing 1+ TextTracks\n * @returns {Array<Object>} An array of TextTrack-like objects.\n */\nexport const parseTracks = (trackOrTracks) => {\n  // Already an array, but might be an array of strings, objects, or both.\n  if (Array.isArray(trackOrTracks)) {\n    return trackOrTracks.map((trackObjOrStr) => {\n      // If the individual track is a string representation, translate it into a TextTrack-like object.\n      if (typeof trackObjOrStr === 'string') {\n        return parseTextTrackStr(trackObjOrStr);\n      }\n      // Otherwise, assume it already is one.\n      return trackObjOrStr;\n    });\n  }\n  // A string of 1+ TextTrack representations. Parse into an array of objects.\n  if (typeof trackOrTracks === 'string') {\n    return parseTextTracksStr(trackOrTracks);\n  }\n  // Assume a single TextTrack-like object. Wrap into an array of 1.\n  return [trackOrTracks];\n};\n\n/**\n * Translates a TextTrack-like object into a well-defined string representation for the TextTrack\n * @param {Object} obj - A TextTrack or TextTrack-like object\n * @param {string} [obj.label] - An optional label for the track.\n * @param {string} obj.language - The BCP-47 compliant string representing the language code of the track\n * @returns {string} A string representing a TextTrack with the format: \"language[:label]\"\n */\nexport const formatTextTrackObj = ({ label, language } = {}) => {\n  if (!label) return language;\n  return `${language}:${encodeURIComponent(label)}`;\n};\n\n/**\n * Translates a set of TextTracks into a well-defined, whitespace-separated string representation of the set\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrackList\n * @param {Array<TextTrack|object>|TextTracks} textTracks - A TextTracks object or an Array of TextTracks or TextTrack-like objects.\n * @returns A string representing a set of TextTracks, separated by whitespace.\n */\nexport const stringifyTextTrackList = (textTracks = []) => {\n  return Array.prototype.map.call(textTracks, formatTextTrackObj).join(' ');\n};\n\n// NOTE: This is a generic higher order fn. Consider and moving to generic module.\n/**\n * A generic higher-order function that yields a predicate to assert whether or not some value has the provided key/value pair\n * @param {string|number} key - The property key/name against which we'd like to match\n * @param {*} value - The value of the key we expect for a match\n * @returns {Function} - A predicate function that yields true if the provided object has the expected key/value pair, otherwise false.\n * @example\n * ```js\n * const hasShowingMode = isMatchingPropOf('mode', 'showing');\n * hasShowingMode({ mode: 'showing' }); // true\n * hasShowingMode({ mode: 'disabled' }); // false\n * hasShowingMode({ no_mode: 'any' }); // false\n * ```\n */\nexport const isMatchingPropOf = (key, value) => (obj) => obj[key] === value;\n\n// NOTE: This is a generic higher order fn. Consider renaming and moving to generic module.\n/**\n * A higher-order function that yields a single predicate to assert whether or not some value has *every* key/value pair defined in `filterObj`.\n * @param {object} filterObj - An object of key/value pairs that we expect on a given object\n * @returns {Function} - A predicate function that yields true iff the provided object has *every* key/value pair in `filterObj`, otherwise false\n * @example\n * ```js\n * const track1 = { label: 'English', kind: 'captions', language: 'en-US' };\n * const track1a = { label: 'English', kind: 'captions', language: 'en-US', id: '1', mode: 'showing' };\n * const track2 = { label: 'English (with descriptions)', kind: 'captions', language: 'en-US', id: '2', mode: 'disabled' };\n * const track3 = { label: 'Espa\u00F1ol', kind: 'subtitles', language: 'es-MX', id: '3', mode: 'disabled' };\n * const track4 = { label: 'English', language: 'en-US', mode: 'showing' };\n *\n * const isMatchingTrack = textTrackObjAsPred({ label: 'English', kind: 'captions', language: 'en-US' });\n * isMatchingTrack(track1); // true\n * isMatchingTrack(track1a); // true\n * isMatchingTrack(track2); // false\n * isMatchingTrack(track3); // false\n * isMatchingTrack(track4); // false\n * isMatchingTrack({ no_corresponding_props: 'any' }); // false\n * ```\n */\nexport const textTrackObjAsPred = (filterObj) => {\n  const preds = Object.entries(filterObj).map(([key, value]) => {\n    // Translate each key/value pair into a single predicate\n    return isMatchingPropOf(key, value);\n  });\n\n  // Return a predicate function that takes the array of single key/value pair predicates and asserts that *every* pred in the array is true of the (TextTrack-like) object\n  return (textTrack) => preds.every((pred) => pred(textTrack));\n};\n\n/**\n * Updates any `tracks` that match one of the `tracksToUpdate` to be in the provided TextTrack `mode`.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/mode\n * @see {@link parseTracks}\n * @param {string} mode - The desired mode for any matching TextTracks. Should be one of \"disabled\"|\"hidden\"|\"showing\"\n * @param {TextTracks|Array<TextTrack|Object>} tracks - A TextTracks object or array of TextTracks that should contain any matching TextTracks to update\n * @param {Array<string|Object>|string|Object} tracksToUpdate - A value representing a set of TextTracks\n */\nexport const updateTracksModeTo = (mode, tracks = [], tracksToUpdate = []) => {\n  // 1. Normalize the tracksToUpdate into an array of \"partial TextTrack-like\" objects\n  // 2. Convert each object into its own predicate function to identify that an actual TextTrack is a match\n  const preds = parseTracks(tracksToUpdate).map(textTrackObjAsPred);\n\n  // A track is identified as a track to update as long as it matches *one* of the preds (i.e. as long as it \"looks like\" one of \"partial TextTrack-like\" objects)\n  const isTrackToUpdate = (textTrack) => {\n    return preds.some((pred) => pred(textTrack));\n  };\n\n  Array.from(tracks)\n    // 1. Filter to only include tracks to update\n    .filter(isTrackToUpdate)\n    // 2. Update each of those tracks to the appropriate mode.\n    .forEach((textTrack) => {\n      textTrack.mode = mode;\n    });\n};\n\n/**\n * Takes an `HTMLMediaElement media` and yields an array of `TextTracks` that match the provided `filterPredOrObj` criteria (or all `TextTracks` by default).\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/textTracks\n * @see {@link textTrackObjAsPred}\n * @param {HTMLMediaElement} media - An HTMLMediaElement with an expected textTracks value\n * (NOTE: This uses \"structural polymorphism\", so as long as `media` has an Array-like `textTracks` value of TextTrack-like objects, this function will work).\n * @param {Function|Object} [filterPredOrObj] Either a predicate function or an object that can be translated into a predicate function of matching key/value pairs.\n * @returns {Array<TextTrack>} An array of TextTracks that match the given `filterPredOrObj` (or all TextTracks on `media` by default)\n * @example\n * ```html\n * <!DOCTYPE html>\n * <html lang=\"en\">\n * <head></head>\n * <body>\n * <video src=\"https://stream.mux.com/DS00Spx1CV902MCtPj5WknGlR102V5HFkDe/high.mp4\">\n *   <track label=\"Spanish\" kind=\"subtitles\" srclang=\"es\" src=\"./vtt/en-sub.vtt\">\n *   <track label=\"English\" kind=\"subtitles\" srclang=\"en\" src=\"./vtt/es-sub.vtt\">\n *   <track label=\"English\" kind=\"captions\" srclang=\"en\" src=\"./vtt/en-cc.vtt\">\n  </video>\n * </body>\n * </html>\n * ```\n * ```js\n * // js ...\n * const media = document.querySelector('video');\n * getTextTracksList(media, { kind: 'subtitles' });\n * // [{ label: 'Spanish', kind: 'subtitles', language: 'es' }, { label: 'English', kind: 'subtitles', language: 'en' }]\n * getTextTracksList(media, { kind: 'captions' });\n * // [{ label: 'English', kind: 'captions', language: 'en' }]\n * getTextTracksList(media);\n * // [{ label: 'Spanish', kind: 'subtitles', language: 'es' }, { label: 'English', kind: 'subtitles', language: 'en' }, { label: 'English', kind: 'captions', language: 'en' }]\n * ```\n */\nexport const getTextTracksList = (media, filterPredOrObj = () => true) => {\n  if (!media?.textTracks) return [];\n\n  const filterPred =\n    typeof filterPredOrObj === 'function'\n      ? filterPredOrObj\n      : textTrackObjAsPred(filterPredOrObj);\n\n  return Array.from(media.textTracks).filter(filterPred);\n};\n"],
  "mappings": "8gBAAA,mQAMO,KAAM,GAAqB,CAAC,EAAgB,KACjD,EAAc,MAAM,OAcT,EAAoB,CAAC,EAAe,KAAO,CACtD,KAAM,CAAC,EAAU,GAAgB,EAAa,MAAM,KAC9C,EAAQ,EAAe,mBAAmB,GAAgB,OAChE,MAAO,CACL,WACA,UAsBS,EAAqB,CAChC,EAAgB,GAChB,EAAmB,KAEZ,EAAmB,GAAe,IAAI,AAAC,GAAiB,CAC7D,KAAM,GAAe,EAAkB,GACvC,MAAO,IACF,KACA,KAUI,EAAc,AAAC,GAEtB,MAAM,QAAQ,GACT,EAAc,IAAI,AAAC,GAEpB,MAAO,IAAkB,SACpB,EAAkB,GAGpB,GAIP,MAAO,IAAkB,SACpB,EAAmB,GAGrB,CAAC,GAUG,EAAqB,CAAC,CAAE,QAAO,YAAa,KAClD,EACE,GAAG,KAAY,mBAAmB,KADtB,EAUR,EAAyB,CAAC,EAAa,KAC3C,MAAM,UAAU,IAAI,KAAK,EAAY,GAAoB,KAAK,KAiB1D,EAAmB,CAAC,EAAK,IAAU,AAAC,GAAQ,EAAI,KAAS,EAwBzD,EAAqB,AAAC,GAAc,CAC/C,KAAM,GAAQ,OAAO,QAAQ,GAAW,IAAI,CAAC,CAAC,EAAK,KAE1C,EAAiB,EAAK,IAI/B,MAAO,AAAC,IAAc,EAAM,MAAM,AAAC,GAAS,EAAK,KAWtC,EAAqB,CAAC,EAAM,EAAS,GAAI,EAAiB,KAAO,CAG5E,KAAM,GAAQ,EAAY,GAAgB,IAAI,GAGxC,EAAkB,AAAC,GAChB,EAAM,KAAK,AAAC,GAAS,EAAK,IAGnC,MAAM,KAAK,GAER,OAAO,GAEP,QAAQ,AAAC,GAAc,CACtB,EAAU,KAAO,KAqCV,EAAoB,CAAC,EAAO,EAAkB,IAAM,KAAS,CACxE,GAAI,CAAC,kBAAO,YAAY,MAAO,GAE/B,KAAM,GACJ,MAAO,IAAoB,WACvB,EACA,EAAmB,GAEzB,MAAO,OAAM,KAAK,EAAM,YAAY,OAAO",
  "names": []
}
