{
  "version": 3,
  "sources": ["../src/js/media-controller.js"],
  "sourcesContent": ["/*\n  The <media-chrome> can contain the control elements\n  and the media element. Features:\n  * Auto-set the `media` attribute on child media chrome elements\n    * Uses the element with slot=\"media\"\n  * Take custom controls to fullscreen\n  * Position controls at the bottom\n  * Auto-hide controls on inactivity while playing\n*/\nimport MediaContainer from './media-container.js';\nimport { defineCustomElement } from './utils/defineCustomElement.js';\nimport {\n  Window as window,\n  Document as document,\n} from './utils/server-safe-globals.js';\nimport { fullscreenApi } from './utils/fullscreenApi.js';\nimport { constToCamel } from './utils/stringUtils.js';\nimport { containsWithShadow } from './utils/element-utils.js';\n\nimport {\n  MediaUIEvents,\n  MediaUIAttributes,\n  TextTrackKinds,\n  TextTrackModes,\n  AvailabilityStates,\n  AttributeToStateChangeEventMap,\n} from './constants.js';\nimport {\n  stringifyTextTrackList,\n  getTextTracksList,\n  updateTracksModeTo,\n} from './utils/captions.js';\nconst {\n  MEDIA_PLAY_REQUEST,\n  MEDIA_PAUSE_REQUEST,\n  MEDIA_MUTE_REQUEST,\n  MEDIA_UNMUTE_REQUEST,\n  MEDIA_VOLUME_REQUEST,\n  MEDIA_ENTER_FULLSCREEN_REQUEST,\n  MEDIA_EXIT_FULLSCREEN_REQUEST,\n  MEDIA_SEEK_REQUEST,\n  MEDIA_PREVIEW_REQUEST,\n  MEDIA_ENTER_PIP_REQUEST,\n  MEDIA_EXIT_PIP_REQUEST,\n  MEDIA_PLAYBACK_RATE_REQUEST,\n} = MediaUIEvents;\n\nclass MediaController extends MediaContainer {\n  constructor() {\n    super();\n\n    if (!airplaySupported) {\n      this._airplayUnavailable = AvailabilityStates.UNSUPPORTED;\n    }\n    if (!pipSupported) {\n      this._pipUnavailable = AvailabilityStates.UNSUPPORTED;\n    }\n    if (volumeSupported !== undefined) {\n      if (!volumeSupported) {\n        this._volumeUnavailable = AvailabilityStates.UNSUPPORTED;\n      }\n    } else {\n      volumeSupportPromise.then(() => {\n        if (!volumeSupported) {\n          this._volumeUnavailable = AvailabilityStates.UNSUPPORTED;\n          this.propagateMediaState(MediaUIAttributes.MEDIA_VOLUME_UNAVAILABLE, this._volumeUnavailable);\n        }\n      });\n    }\n\n    // Include this for styling convenience or exclude since it\n    // can be derived from MEDIA_CAPTIONS_LIST && MEDIA_SUBTITLES_LIST? (CJP)\n    // this._captionsUnavailable;\n\n    // Track externally associated control elements\n    this.mediaStateReceivers = [];\n    this.associatedElementSubscriptions = new Map();\n    this.associatedElements = [];\n    this.associateElement(this);\n\n    // Capture request events from internal controls\n    const mediaUIEventHandlers = {\n      MEDIA_PLAY_REQUEST: () => this.media.play(),\n      MEDIA_PAUSE_REQUEST: () => this.media.pause(),\n      MEDIA_MUTE_REQUEST: () => (this.media.muted = true),\n      MEDIA_UNMUTE_REQUEST: () => {\n        const media = this.media;\n\n        media.muted = false;\n\n        // Avoid confusion by bumping the volume on unmute\n        if (media.volume === 0) {\n          media.volume = 0.25;\n        }\n      },\n      MEDIA_VOLUME_REQUEST: (e) => {\n        const media = this.media;\n        const volume = e.detail;\n\n        media.volume = volume;\n\n        // If the viewer moves the volume we should unmute for them.\n        if (volume > 0 && media.muted) {\n          media.muted = false;\n        }\n\n        // Store the last set volume as a local preference, if ls is supported\n        try {\n          window.localStorage.setItem(\n            'media-chrome-pref-volume',\n            volume.toString()\n          );\n        } catch (err) {}\n      },\n\n      // This current assumes that the media controller is the fullscreen element\n      // which may be true in most cases but not all.\n      // The prior version of media-chrome supported alt fullscreen elements\n      // and that's something we can work towards here.\n      //\n      // Generally the fullscreen and PiP API's have the exit methods and enabled\n      // flags on the `document`. The active element is accessed on the document\n      // or shadow root but Safari doesn't support this.\n      // Entering fullscreen or PiP is called on the element. i.e.\n      //\n      //   - Document.exitFullscreen()\n      //   - Document.fullscreenEnabled\n      //   - Document.fullscreenElement / (ShadowRoot.fullscreenElement)\n      //   - Element.requestFullscreen()\n      //\n      MEDIA_ENTER_FULLSCREEN_REQUEST: () => {\n        const media = this.media;\n\n        if (document.pictureInPictureElement) {\n          // Should be async\n          document.exitPictureInPicture();\n        }\n\n        if (super[fullscreenApi.enter]) {\n          // Media chrome container fullscreen\n          super[fullscreenApi.enter]();\n        } else if (media.webkitEnterFullscreen) {\n          // Media element fullscreen using iOS API\n          media.webkitEnterFullscreen();\n        } else if (media.requestFullscreen) {\n          // Media element fullscreen, using correct API\n          // So media els don't have to implement multiple APIs.\n          media.requestFullscreen();\n        } else {\n          console.warn('MediaChrome: Fullscreen not supported');\n        }\n      },\n      MEDIA_EXIT_FULLSCREEN_REQUEST: () => {\n        document[fullscreenApi.exit]();\n      },\n      MEDIA_ENTER_PIP_REQUEST: () => {\n        const media = this.media;\n\n        if (!document.pictureInPictureEnabled) return;\n\n        // Exit fullscreen if needed\n        if (document[fullscreenApi.element]) {\n          document[fullscreenApi.exit]();\n        }\n\n        media.requestPictureInPicture();\n      },\n      MEDIA_EXIT_PIP_REQUEST: () => {\n        if (document.pictureInPictureElement) {\n          // Should be async\n          document.exitPictureInPicture();\n        }\n      },\n      MEDIA_SEEK_REQUEST: (e) => {\n        const media = this.media;\n        const time = e.detail;\n\n        // Can't set the time before the media is ready\n        // Ignore if readyState isn't supported\n        if (media.readyState > 0 || media.readyState === undefined) {\n          media.currentTime = time;\n        }\n      },\n      MEDIA_PLAYBACK_RATE_REQUEST: (e) => {\n        this.media.playbackRate = e.detail;\n      },\n      MEDIA_PREVIEW_REQUEST: (e) => {\n        const media = this.media;\n        // No media (yet), so bail early\n        if (!media) return;\n\n        const [track] = getTextTracksList(media, {\n          kind: TextTrackKinds.METADATA,\n          label: 'thumbnails',\n        });\n        // No thumbnails track (yet) or no cues available in thumbnails track, so bail early.\n        if (!(track && track.cues)) return;\n\n        const time = e.detail;\n        const cue = Array.prototype.find.call(\n          track.cues,\n          (c) => c.startTime >= time\n        );\n\n        // No corresponding cue, so bail early\n        if (!cue) return;\n\n        // Since this isn't really \"global state\", we may want to consider moving this \"down\" to the component level,\n        // probably pulled out into its own module/set of functions (CJP)\n        const base = !/'^(?:[a-z]+:)?\\/\\//i.test(cue.text)\n          ? media.querySelector('track[label=\"thumbnails\"]')?.src\n          : undefined;\n        const url = new URL(cue.text, base);\n        const previewCoordsStr = new URLSearchParams(url.hash).get('#xywh');\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_PREVIEW_IMAGE,\n          url.href\n        );\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_PREVIEW_COORDS,\n          previewCoordsStr.split(',').join(' ')\n        );\n      },\n      MEDIA_SHOW_CAPTIONS_REQUEST: (e) => {\n        const tracks = getCaptionTracks(this);\n        const { detail: tracksToUpdate = [] } = e;\n        updateTracksModeTo(TextTrackModes.SHOWING, tracks, tracksToUpdate);\n      },\n      // NOTE: We're currently recommending and providing default components that will \"disable\" tracks when\n      // we don't want them shown (rather than \"hiding\" them).\n      // For a discussion why, see: https://github.com/muxinc/media-chrome/issues/60\n      MEDIA_DISABLE_CAPTIONS_REQUEST: (e) => {\n        const tracks = getCaptionTracks(this);\n        const { detail: tracksToUpdate = [] } = e;\n        updateTracksModeTo(TextTrackModes.DISABLED, tracks, tracksToUpdate);\n      },\n      MEDIA_SHOW_SUBTITLES_REQUEST: (e) => {\n        const tracks = getSubtitleTracks(this);\n        const { detail: tracksToUpdate = [] } = e;\n        updateTracksModeTo(TextTrackModes.SHOWING, tracks, tracksToUpdate);\n      },\n      MEDIA_DISABLE_SUBTITLES_REQUEST: (e) => {\n        const tracks = getSubtitleTracks(this);\n        const { detail: tracksToUpdate = [] } = e;\n        updateTracksModeTo(TextTrackModes.DISABLED, tracks, tracksToUpdate);\n      },\n      MEDIA_AIRPLAY_REQUEST: (_e) => {\n        const { media } = this;\n        if (!media) return;\n        if (\n          !(\n            media.webkitShowPlaybackTargetPicker &&\n            window.WebKitPlaybackTargetAvailabilityEvent\n          )\n        ) {\n          console.warn(\n            'received a request to select AirPlay but AirPlay is not supported in this environment'\n          );\n          return;\n        }\n        media.webkitShowPlaybackTargetPicker();\n      },\n    };\n\n    // Apply ui event listeners\n    Object.keys(mediaUIEventHandlers).forEach((key) => {\n      const handlerName = `_handle${constToCamel(key, true)}`;\n\n      this[handlerName] = (e) => {\n        // Stop media UI events from continuing to bubble\n        e.stopPropagation();\n\n        if (!this.media) {\n          console.warn('MediaController: No media available.');\n          return;\n        }\n\n        mediaUIEventHandlers[key](e, this.media);\n      };\n      this.addEventListener(MediaUIEvents[key], this[handlerName]);\n    });\n\n    // Pass media state to child and associated control elements\n    this._mediaStatePropagators = {\n      'play,pause,emptied': () => {\n        this.propagateMediaState(MediaUIAttributes.MEDIA_PAUSED, getPaused(this));\n      },\n      'playing,emptied': () => {\n        // We want to let the user know that the media started playing at any point (`media-has-played`).\n        // Since these propagators are all called when boostrapping state, let's verify this is\n        // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n        this.propagateMediaState(MediaUIAttributes.MEDIA_HAS_PLAYED, !this.media?.paused);\n      }, \n      volumechange: () => {\n        this.propagateMediaState(MediaUIAttributes.MEDIA_MUTED, getMuted(this));\n        this.propagateMediaState(MediaUIAttributes.MEDIA_VOLUME, getVolume(this));\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_VOLUME_LEVEL,\n          getVolumeLevel(this)\n        );\n      },\n      [fullscreenApi.event]: () => {\n        // If media-chrome is in the shadow dom this.getRootNode().host will\n        // be the fullscreen element otherwise this controller will be.\n        let fullscreenEl = document[fullscreenApi.element];\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_IS_FULLSCREEN,\n          fullscreenEl === (this.getRootNode().host ?? this)\n        );\n      },\n      'enterpictureinpicture,leavepictureinpicture': (e) => {\n        let isPip;\n\n        // Rely on event type for state first\n        // in case this doesn't work well for custom elements using internal <video>\n        if (e) {\n          isPip = e.type == 'enterpictureinpicture';\n        } else {\n          const pipElement =\n            this.getRootNode().pictureInPictureElement ??\n            document.pictureInPictureElement;\n          isPip = this.media && containsWithShadow(this.media, pipElement);\n        }\n        this.propagateMediaState(MediaUIAttributes.MEDIA_IS_PIP, isPip);\n      },\n      'timeupdate,loadedmetadata': () => {\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_CURRENT_TIME,\n          getCurrentTime(this)\n        );\n      },\n      'durationchange,loadedmetadata,emptied': () => {\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_DURATION,\n          getDuration(this)\n        );\n      },\n      'progress,emptied': () => {\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_BUFFERED,\n          serializeTimeRanges(this.media?.buffered)\n        );\n      },\n      ratechange: () => {\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_PLAYBACK_RATE,\n          getPlaybackRate(this)\n        );\n      },\n      'waiting,playing,emptied': () => {\n        const isLoading = this.media?.readyState < 3;\n        this.propagateMediaState(MediaUIAttributes.MEDIA_LOADING, isLoading);\n      },\n    };\n\n    if (this._airplayUnavailable !== AvailabilityStates.UNSUPPORTED) {\n      const airplaySupporHandler = (event) => {\n        // NOTE: since we invoke all these event handlers without arguments whenever a media is attached,\n        // need to account for the possibility that event is undefined (CJP).\n        if (event?.availability === 'available') {\n          this._airplayUnavailable = undefined;\n        } else if (event?.availability === 'not-available') {\n          this._airplayUnavailable = AvailabilityStates.UNAVAILABLE;\n        }\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE,\n          this._airplayUnavailable\n        );\n      };\n      // NOTE: only adding this if airplay is supported, in part to avoid unnecessary battery consumption per\n      // Apple docs recommendations (See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls)\n      // For a more advanced solution, we could monitor for media state receivers that \"care\" about airplay support and add/remove\n      // whenever these are added/removed. (CJP)\n      this._mediaStatePropagators['webkitplaybacktargetavailabilitychanged'] =\n        airplaySupporHandler;\n    }\n\n    /**\n     * @TODO This and _mediaStatePropagators should be refactored to be less presumptuous about what is being\n     * monitored (and also probably how it's being monitored) (CJP)\n     */\n    this._textTrackMediaStatePropagators = {\n      'addtrack,removetrack,loadstart': () => {\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_CAPTIONS_LIST,\n          stringifyTextTrackList(getCaptionTracks(this)) || undefined\n        );\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_SUBTITLES_LIST,\n          stringifyTextTrackList(getSubtitleTracks(this)) || undefined\n        );\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_CAPTIONS_SHOWING,\n          stringifyTextTrackList(getShowingCaptionTracks(this)) || undefined\n        );\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_SUBTITLES_SHOWING,\n          stringifyTextTrackList(getShowingSubtitleTracks(this)) || undefined\n        );\n      },\n      change: () => {\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_CAPTIONS_SHOWING,\n          stringifyTextTrackList(getShowingCaptionTracks(this)) || undefined\n        );\n        this.propagateMediaState(\n          MediaUIAttributes.MEDIA_SUBTITLES_SHOWING,\n          stringifyTextTrackList(getShowingSubtitleTracks(this)) || undefined\n        );\n      },\n    };\n  }\n\n  mediaSetCallback(media) {\n    super.mediaSetCallback(media);\n    // Listen for media state changes and propagate them to children and associated els\n    Object.keys(this._mediaStatePropagators).forEach((key) => {\n      const events = key.split(',');\n      const handler = this._mediaStatePropagators[key];\n\n      events.forEach((event) => {\n        // If this is fullscreen apply to the document\n        const target =\n          event == fullscreenApi.event ? this.getRootNode() : media;\n\n        target.addEventListener(event, handler);\n      });\n      handler();\n    });\n\n    Object.entries(this._textTrackMediaStatePropagators).forEach(\n      ([eventsStr, handler]) => {\n        const events = eventsStr.split(',');\n        events.forEach((event) => {\n          if (media.textTracks) {\n            media.textTracks.addEventListener(event, handler);\n          }\n        });\n        handler();\n      }\n    );\n\n    // Update the media with the last set volume preference\n    // This would preferably live with the media element,\n    // not a control.\n    try {\n      const volPref = window.localStorage.getItem('media-chrome-pref-volume');\n      if (volPref !== null) media.volume = volPref;\n    } catch (e) {\n      console.debug('Error getting volume pref', e);\n    }\n  }\n\n  mediaUnsetCallback(media) {\n    super.mediaUnsetCallback(media);\n\n    // Remove all state change propagators\n    Object.keys(this._mediaStatePropagators).forEach((key) => {\n      const events = key.split(',');\n      const handler = this._mediaStatePropagators[key];\n\n      events.forEach((event) => {\n        const target =\n          event == fullscreenApi.event ? this.getRootNode() : media;\n        target.removeEventListener(event, handler);\n      });\n    });\n\n    Object.entries(this._textTrackMediaStatePropagators).forEach(\n      ([eventsStr, handler]) => {\n        const events = eventsStr.split(',');\n        events.forEach((event) => {\n          if (media.textTracks) {\n            media.textTracks.removeEventListener(event, handler);\n          }\n        });\n        handler();\n      }\n    );\n\n    // Reset to paused state\n    this.propagateMediaState(MediaUIAttributes.MEDIA_PAUSED, true);\n  }\n\n  propagateMediaState(stateName, state) {\n    propagateMediaState(this.mediaStateReceivers, stateName, state);\n    const evt = new window.CustomEvent(\n      AttributeToStateChangeEventMap[stateName],\n      { composed: true, bubbles: true, detail: state }\n    );\n    this.dispatchEvent(evt);\n  }\n\n  associateElement(element) {\n    if (!element) return;\n    const { associatedElementSubscriptions } = this;\n\n    if (associatedElementSubscriptions.has(element)) return;\n\n    const registerMediaStateReceiver =\n      this.registerMediaStateReceiver.bind(this);\n    const unregisterMediaStateReceiver =\n      this.unregisterMediaStateReceiver.bind(this);\n\n    /** @TODO Should we support \"removing association\" */\n    const unsubscribe = monitorForMediaStateReceivers(\n      element,\n      registerMediaStateReceiver,\n      unregisterMediaStateReceiver\n    );\n\n    // Add all media request event listeners to the Associated Element. This allows any DOM element that\n    // is a descendant of any Associated Element (including the <media-controller/> itself) to make requests\n    // for media state changes rather than constraining that exclusively to a Media State Receivers.\n    Object.keys(MediaUIEvents).forEach((key) => {\n      element.addEventListener(\n        MediaUIEvents[key],\n        this[`_handle${constToCamel(key, true)}`]\n      );\n    });\n\n    associatedElementSubscriptions.set(element, unsubscribe);\n  }\n\n  unassociateElement(element) {\n    if (!element) return;\n    const { associatedElementSubscriptions } = this;\n    if (!associatedElementSubscriptions.has(element)) return;\n    const unsubscribe = associatedElementSubscriptions.get(element);\n    unsubscribe();\n    associatedElementSubscriptions.delete(element);\n\n    // Remove all media UI event listeners\n    Object.keys(MediaUIEvents).forEach((key) => {\n      element.removeEventListener(\n        MediaUIEvents[key],\n        this[`_handle${constToCamel(key, true)}`]\n      );\n    });\n  }\n\n  registerMediaStateReceiver(el) {\n    if (!el) return;\n    const els = this.mediaStateReceivers;\n    const index = els.indexOf(el);\n    if (index > -1) return;\n\n    els.push(el);\n\n    // No media depedencies, so push regardless of media availability.\n    propagateMediaState(\n      [el],\n      MediaUIAttributes.MEDIA_VOLUME_UNAVAILABLE,\n      this._volumeUnavailable\n    );\n    propagateMediaState(\n      [el],\n      MediaUIAttributes.MEDIA_AIRPLAY_UNAVAILABLE,\n      this._airplayUnavailable\n    );\n    propagateMediaState(\n      [el],\n      MediaUIAttributes.MEDIA_PIP_UNAVAILABLE,\n      this._pipUnavailable,\n    );\n\n    // TODO: Update to propagate all states when registered\n    if (this.media) {\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_CAPTIONS_LIST,\n        stringifyTextTrackList(getCaptionTracks(this)) || undefined\n      );\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_SUBTITLES_LIST,\n        stringifyTextTrackList(getSubtitleTracks(this)) || undefined\n      );\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_CAPTIONS_SHOWING,\n        stringifyTextTrackList(getShowingCaptionTracks(this)) || undefined\n      );\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_SUBTITLES_SHOWING,\n        stringifyTextTrackList(getShowingSubtitleTracks(this)) || undefined\n      );\n      propagateMediaState([el], MediaUIAttributes.MEDIA_PAUSED, getPaused(this));\n      // propagateMediaState([el], MediaUIAttributes.MEDIA_VOLUME_LEVEL, level);\n      propagateMediaState([el], MediaUIAttributes.MEDIA_MUTED, getMuted(this));\n      propagateMediaState([el], MediaUIAttributes.MEDIA_VOLUME, getVolume(this));\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_VOLUME_LEVEL,\n        getVolumeLevel(this)\n      );\n      // const fullscreenEl = this.getRootNode()[fullscreenApi.element];\n      // propagateMediaState([el], MediaUIAttributes.MEDIA_IS_FULLSCREEN, fullscreenEl === this);\n      // propagateMediaState([el], MediaUIAttributes.MEDIA_IS_PIP, isPip);\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_CURRENT_TIME,\n        getCurrentTime(this)\n      );\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_DURATION,\n        getDuration(this)\n      );\n      propagateMediaState(\n        [el],\n        MediaUIAttributes.MEDIA_PLAYBACK_RATE,\n        getPlaybackRate(this)\n      );\n    }\n  }\n\n  unregisterMediaStateReceiver(el) {\n    const els = this.mediaStateReceivers;\n\n    const index = els.indexOf(el);\n    if (index < 0) return;\n\n    els.splice(index, 1);\n  }\n\n  /**\n   * Media Controller should not mimic the HTMLMediaElement API.\n   * @see https://github.com/muxinc/media-chrome/pull/182#issuecomment-1067370339\n   */\n}\n\nconst getPaused = (controller) => {\n  if (!controller.media) return true;\n\n  return controller.media.paused;\n};\n\nconst getMuted = (controller) => {\n  return !!(controller.media && controller.media.muted);\n};\n\nconst getVolume = (controller) => {\n  const media = controller.media;\n\n  return media ? media.volume : 1;\n};\n\nconst getVolumeLevel = (controller) => {\n  let level = 'high';\n\n  if (!controller.media) return level;\n\n  const { muted, volume } = controller.media;\n\n  if (volume === 0 || muted) {\n    level = 'off';\n  } else if (volume < 0.5) {\n    level = 'low';\n  } else if (volume < 0.75) {\n    level = 'medium';\n  }\n\n  return level;\n};\n\nconst getCurrentTime = (controller) => {\n  const media = controller.media;\n\n  return media ? media.currentTime : 0;\n};\n\nconst getDuration = (controller) => {\n  const media = controller.media;\n\n  return media ? media.duration : NaN;\n};\n\nconst getPlaybackRate = (controller) => {\n  const media = controller.media;\n\n  return media ? media.playbackRate : 1;\n};\n\nconst getSubtitleTracks = (controller) => {\n  return getTextTracksList(controller.media, { kind: TextTrackKinds.SUBTITLES });\n};\n\nconst getCaptionTracks = (controller) => {\n  return getTextTracksList(controller.media, { kind: TextTrackKinds.CAPTIONS });\n};\n\nconst getShowingSubtitleTracks = (controller) => {\n  return getTextTracksList(controller.media, {\n    kind: TextTrackKinds.SUBTITLES,\n    mode: TextTrackModes.SHOWING,\n  });\n};\n\nconst getShowingCaptionTracks = (controller) => {\n  return getTextTracksList(controller.media, {\n    kind: TextTrackKinds.CAPTIONS,\n    mode: TextTrackModes.SHOWING,\n  });\n};\n\nconst MEDIA_UI_ATTRIBUTE_NAMES = Object.values(MediaUIAttributes);\n\nconst getMediaUIAttributesFrom = (child) => {\n  const {\n    constructor: { observedAttributes },\n  } = child;\n  const mediaChromeAttributesList = child\n    ?.getAttribute?.(MediaUIAttributes.MEDIA_CHROME_ATTRIBUTES)\n    ?.split?.(/\\s+/);\n  if (!Array.isArray(observedAttributes || mediaChromeAttributesList))\n    return [];\n  return (observedAttributes || mediaChromeAttributesList).filter((attrName) =>\n    MEDIA_UI_ATTRIBUTE_NAMES.includes(attrName)\n  );\n};\n\nconst isMediaStateReceiver = (child) => {\n  return !!getMediaUIAttributesFrom(child).length;\n};\n\nconst setAttr = async (child, attrName, attrValue) => {\n  // If the node is not connected to the DOM yet wait on macrotask. Fix for:\n  //   Uncaught DOMException: Failed to construct 'CustomElement':\n  //   The result must not have attributes\n  if (!child.isConnected) {\n    await delay(0);\n  }\n\n  if (attrValue == undefined) {\n    return child.removeAttribute(attrName);\n  }\n  if (typeof attrValue === 'boolean') {\n    if (attrValue) return child.setAttribute(attrName, '');\n    return child.removeAttribute(attrName);\n  }\n  if (Number.isNaN(attrValue)) {\n    return child.removeAttribute(attrName);\n  }\n  return child.setAttribute(attrName, attrValue);\n};\n\nconst isMediaSlotElementDescendant = (el) => !!el.closest?.('*[slot=\"media\"]');\n\n/**\n *\n * @description This function will recursively check for any descendants (including the rootNode)\n * that are Media State Receivers and invoke `mediaStateReceiverCallback` with any Media State Receiver\n * found\n *\n * @param {HTMLElement} rootNode\n * @param {function} mediaStateReceiverCallback\n */\nconst traverseForMediaStateReceivers = (\n  rootNode,\n  mediaStateReceiverCallback\n) => {\n  // We (currently) don't check if descendants of the `media` (e.g. <video/>) are Media State Receivers\n  // See also: `propagateMediaState`\n  if (isMediaSlotElementDescendant(rootNode)) {\n    return;\n  }\n\n  const traverseForMediaStateReceiversSync = (\n    rootNode,\n    mediaStateReceiverCallback\n  ) => {\n    // The rootNode is itself a Media State Receiver\n    if (isMediaStateReceiver(rootNode)) {\n      mediaStateReceiverCallback(rootNode);\n    }\n\n    const { children = [] } = rootNode ?? {};\n    const shadowChildren = rootNode?.shadowRoot?.children ?? [];\n    const allChildren = [...children, ...shadowChildren];\n\n    // Traverse all children (including shadowRoot children) to see if they are/have Media State Receivers\n    allChildren.forEach((child) =>\n      traverseForMediaStateReceivers(child, mediaStateReceiverCallback)\n    );\n  };\n\n  // Custom Elements (and *only* Custom Elements) must have a hyphen (\"-\") in their name. So, if the rootNode is\n  // a custom element (aka has a hyphen in its name), wait until it's defined before attempting traversal to determine\n  // whether or not it or its descendants are Media State Receivers.\n  // IMPORTANT NOTE: We're intentionally *always* waiting for the `whenDefined()` Promise to resolve here\n  // (instead of using `window.customElements.get(name)` to check if a custom element is already defined/registered)\n  // because we encountered some reliability issues with the custom element instances not being fully \"ready\", even if/when\n  // they are available in the registry via `window.customElements.get(name)`.\n  const name = rootNode?.nodeName.toLowerCase();\n  if (name.includes('-') && !isMediaStateReceiver(rootNode)) {\n    window.customElements.whenDefined(name).then(() => {\n      // Try/traverse again once the custom element is defined\n      traverseForMediaStateReceiversSync(rootNode, mediaStateReceiverCallback);\n    });\n    return;\n  }\n\n  traverseForMediaStateReceiversSync(rootNode, mediaStateReceiverCallback);\n};\n\nconst propagateMediaState = (els, stateName, val) => {\n  els.forEach((el) => {\n    const relevantAttrs = getMediaUIAttributesFrom(el);\n    if (!relevantAttrs.includes(stateName)) return;\n    setAttr(el, stateName, val);\n  });\n};\n\n/**\n *\n * @description This function will monitor the rootNode for any Media State Receiver descendants\n * that are already present, added, or removed, invoking the relevant callback function for each\n * case.\n *\n * @param {HTMLElement} rootNode\n * @param {function} registerMediaStateReceiver\n * @param {function} unregisterMediaStateReceiver\n * @returns An unsubscribe method, used to stop monitoring descendants of rootNode and to unregister its descendants\n *\n */\nconst monitorForMediaStateReceivers = (\n  rootNode,\n  registerMediaStateReceiver,\n  unregisterMediaStateReceiver\n) => {\n  // First traverse the tree to register any current Media State Receivers\n  traverseForMediaStateReceivers(rootNode, registerMediaStateReceiver);\n\n  // Monitor for any event-based requests from descendants to register/unregister as a Media State Receiver\n  const registerMediaStateReceiverHandler = (evt) => {\n    const el = evt?.composedPath()[0] ?? evt.target;\n    registerMediaStateReceiver(el);\n  };\n\n  const unregisterMediaStateReceiverHandler = (evt) => {\n    const el = evt?.composedPath()[0] ?? evt.target;\n    unregisterMediaStateReceiver(el);\n  };\n\n  rootNode.addEventListener(\n    MediaUIEvents.REGISTER_MEDIA_STATE_RECEIVER,\n    registerMediaStateReceiverHandler\n  );\n  rootNode.addEventListener(\n    MediaUIEvents.UNREGISTER_MEDIA_STATE_RECEIVER,\n    unregisterMediaStateReceiverHandler\n  );\n\n  // Observe any changes to the DOM for any descendants that are identifiable as Media State Receivers\n  // and register or unregister them, depending on the change that occurred.\n  const mutationCallback = (mutationsList, _observer) => {\n    mutationsList.forEach((mutationRecord) => {\n      const {\n        addedNodes = [],\n        removedNodes = [],\n        type,\n        target,\n        attributeName,\n      } = mutationRecord;\n      if (type === 'childList') {\n        // For each added node, register any Media State Receiver descendants (including itself)\n        Array.prototype.forEach.call(addedNodes, (node) =>\n          traverseForMediaStateReceivers(node, registerMediaStateReceiver)\n        );\n        // For each removed node, unregister any Media State Receiver descendants (including itself)\n        Array.prototype.forEach.call(removedNodes, (node) =>\n          traverseForMediaStateReceivers(node, unregisterMediaStateReceiver)\n        );\n      } else if (\n        type === 'attributes' &&\n        attributeName === MediaUIAttributes.MEDIA_CHROME_ATTRIBUTES\n      ) {\n        if (isMediaStateReceiver(target)) {\n          // Changed from a \"non-Media State Receiver\" to a Media State Receiver: register it.\n          registerMediaStateReceiver(target);\n        } else {\n          // Changed from a Media State Receiver to a \"non-Media State Receiver\": unregister it.\n          unregisterMediaStateReceiver(target);\n        }\n      }\n    });\n  };\n\n  const observer = new MutationObserver(mutationCallback);\n  observer.observe(rootNode, {\n    childList: true,\n    attributes: true,\n    subtree: true,\n  });\n\n  const unsubscribe = () => {\n    // Unregister any Media State Receiver descendants (including ourselves)\n    traverseForMediaStateReceivers(rootNode, unregisterMediaStateReceiver);\n    // Stop observing for Media State Receivers\n    observer.disconnect();\n    // Stop listening for Media State Receiver events.\n    rootNode.removeEventListener(\n      MediaUIEvents.REGISTER_MEDIA_STATE_RECEIVER,\n      registerMediaStateReceiverHandler\n    );\n    rootNode.removeEventListener(\n      MediaUIEvents.UNREGISTER_MEDIA_STATE_RECEIVER,\n      unregisterMediaStateReceiverHandler\n    );\n  };\n\n  return unsubscribe;\n};\n\nlet testMediaEl;\nexport const getTestMediaEl = () => {\n  if (testMediaEl) return testMediaEl;\n  testMediaEl = document?.createElement?.('video');\n  return testMediaEl;\n};\n\nexport const hasVolumeSupportAsync = async (mediaEl = getTestMediaEl()) => {\n  if (!mediaEl) return false;\n  const prevVolume = mediaEl.volume;\n  mediaEl.volume = prevVolume / 2 + 0.1;\n  await delay(0);\n  return mediaEl.volume !== prevVolume;\n};\n\n/**\n * Returns a promise that will resolve after passed ms.\n * @param  {number} ms\n * @return {Promise}\n */\nexport const delay = (ms) => new Promise((resolve, reject) => setTimeout(resolve, ms));\n\nexport const hasPipSupport = (mediaEl = getTestMediaEl()) =>\n  typeof mediaEl?.requestPictureInPicture === 'function';\n\nconst pipSupported = hasPipSupport();\n\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then((supported) => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\n\nconst airplaySupported = !!window.WebKitPlaybackTargetAvailabilityEvent;\n\nfunction serializeTimeRanges(timeRanges = []) {\n  return Array.from(timeRanges)\n    .map((_, i) => [\n      Number(timeRanges.start(i).toFixed(2)),\n      Number(timeRanges.end(i).toFixed(2)),\n    ].join(':'))\n    .join(' ');\n}\n\ndefineCustomElement('media-controller', MediaController);\n\nexport default MediaController;\n"],
  "mappings": "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",
  "names": []
}
