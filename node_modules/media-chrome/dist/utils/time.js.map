{
  "version": 3,
  "sources": ["../../src/js/utils/time.js"],
  "sourcesContent": ["// Consider moving this to a more generic utils module\nconst isValidNumber = (x) =>\n  typeof x === 'number' && !Number.isNaN(x) && Number.isFinite(x);\n\nconst UnitLabels = [\n  {\n    singular: 'hour',\n    plural: 'hours',\n  },\n  {\n    singular: 'minute',\n    plural: 'minutes',\n  },\n  {\n    singular: 'second',\n    plural: 'seconds',\n  },\n];\nconst toTimeUnitPhrase = (timeUnitValue, unitIndex) => {\n  const unitLabel =\n    timeUnitValue === 1\n      ? UnitLabels[unitIndex].singular\n      : UnitLabels[unitIndex].plural;\n\n  return `${timeUnitValue} ${unitLabel}`;\n};\n\n/**\n * This function converts numeric seconds into a phrase\n * @param {number} seconds - a (positive or negative) time, represented as seconds\n * @returns {string} The time, represented as a phrase of hours, minutes, and seconds\n */\nexport const formatAsTimePhrase = (seconds) => {\n  if (!isValidNumber(seconds)) return '';\n  const positiveSeconds = Math.abs(seconds);\n  const negative = positiveSeconds !== seconds;\n  const secondsDateTime = new Date(0, 0, 0, 0, 0, positiveSeconds, 0);\n  const timeParts = [\n    secondsDateTime.getHours(),\n    secondsDateTime.getMinutes(),\n    secondsDateTime.getSeconds(),\n  ];\n  // NOTE: Everything above should be useable for the `formatTime` function.\n\n  const timeString = timeParts\n    // Convert non-0 values to a string of the value plus its unit\n    .map(\n      (timeUnitValue, index) =>\n        timeUnitValue && toTimeUnitPhrase(timeUnitValue, index)\n    )\n    // Ignore/exclude any 0 values\n    .filter((x) => x)\n    // join into a single comma-separated string phrase\n    .join(', ');\n\n  // If the time was negative, assume it represents some remaining amount of time/\"count down\".\n  const negativeSuffix = negative ? ' remaining' : '';\n\n  return `${timeString}${negativeSuffix}`;\n};\n\nexport function formatTime(seconds, guide) {\n  // Handle negative values at the end\n  let negative = false;\n\n  if (seconds < 0) {\n    negative = true;\n    seconds = 0 - seconds;\n  }\n\n  seconds = seconds < 0 ? 0 : seconds;\n  let s = Math.floor(seconds % 60);\n  let m = Math.floor((seconds / 60) % 60);\n  let h = Math.floor(seconds / 3600);\n  const gm = Math.floor((guide / 60) % 60);\n  const gh = Math.floor(guide / 3600);\n\n  // handle invalid times\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this setting\n    // will add the minimum number of fields specified by the guide\n    h = m = s = '-';\n  }\n\n  // Check if we need to show hours\n  h = h > 0 || gh > 0 ? h + ':' : '';\n\n  // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n  // Check if leading zero is need for seconds\n  s = s < 10 ? '0' + s : s;\n\n  return (negative ? '-' : '') + h + m + s;\n}\n"],
  "mappings": "AACA,KAAM,GAAgB,AAAC,GACrB,MAAO,IAAM,UAAY,CAAC,OAAO,MAAM,IAAM,OAAO,SAAS,GAEzD,EAAa,CACjB,CACE,SAAU,OACV,OAAQ,SAEV,CACE,SAAU,SACV,OAAQ,WAEV,CACE,SAAU,SACV,OAAQ,YAGN,EAAmB,CAAC,EAAe,IAAc,CACrD,KAAM,GACJ,IAAkB,EACd,EAAW,GAAW,SACtB,EAAW,GAAW,OAE5B,MAAO,GAAG,KAAiB,KAQhB,EAAqB,AAAC,GAAY,CAC7C,GAAI,CAAC,EAAc,GAAU,MAAO,GACpC,KAAM,GAAkB,KAAK,IAAI,GAC3B,EAAW,IAAoB,EAC/B,EAAkB,GAAI,MAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAiB,GAsBjE,MAAO,GAdY,AAPD,CAChB,EAAgB,WAChB,EAAgB,aAChB,EAAgB,cAMf,IACC,CAAC,EAAe,IACd,GAAiB,EAAiB,EAAe,IAGpD,OAAO,AAAC,GAAM,GAEd,KAAK,QAGe,EAAW,aAAe,MAK5C,WAAoB,EAAS,EAAO,CAEzC,GAAI,GAAW,GAEf,AAAI,EAAU,GACZ,GAAW,GACX,EAAU,EAAI,GAGhB,EAAU,EAAU,EAAI,EAAI,EAC5B,GAAI,GAAI,KAAK,MAAM,EAAU,IACzB,EAAI,KAAK,MAAO,EAAU,GAAM,IAChC,EAAI,KAAK,MAAM,EAAU,MAC7B,KAAM,GAAK,KAAK,MAAO,EAAQ,GAAM,IAC/B,EAAK,KAAK,MAAM,EAAQ,MAG9B,MAAI,OAAM,IAAY,IAAY,MAGhC,GAAI,EAAI,EAAI,KAId,EAAI,EAAI,GAAK,EAAK,EAAI,EAAI,IAAM,GAIhC,EAAM,KAAK,GAAM,KAAO,EAAI,GAAK,IAAM,EAAI,GAAK,IAGhD,EAAI,EAAI,GAAK,IAAM,EAAI,EAEf,GAAW,IAAM,IAAM,EAAI,EAAI",
  "names": []
}
